#ifndef DGGML_SOLVER_H
#define DGGML_SOLVER_H

#include <arkode/arkode_erkstep.h>
#include <nvector/nvector_serial.h>
#include <sundials/sundials_types.h>
#include <sundials/sundials_math.h>

#if defined(SUNDIALS_EXTENDED_PRECISION)
#define GSYM "Lg"
#define ESYM "Le"
#define FSYM "Lf"
#else
#define GSYM "g"
#define ESYM "e"
#define FSYM "f"
#endif

#include <vector>

#include "SundialsUtils.hpp"
#include "HelperFunctions.hpp"

// TODO: Need to generalize the sovler code and we need to add in the root finding fix from
// CajeteCMA repo
namespace DGGML {

    template <typename ModelType, typename AnalyzedGrammarType, typename RuleMatchType, typename ComponentMatchType>
    struct Solver
    {
        int flag; //generic reusable flag

        //Create the suncontext
        SUNContext ctx;
        void* arkode_mem;

        realtype t_start, t_final, t, tout, dt_out;

        realtype reltol;
        realtype abstol;

        static constexpr int num_roots = 1;
        int roots_found[num_roots];
        int root_flag;

        sunindextype num_eq;

        N_Vector y;
        std::size_t global_nstep;
        //Note: by hiding it in the solver, we can add extra
        //data generated by the constructor and not the user
        // to be passed into the rhs
        struct UserDataType
        {
            ModelType& model;
            AnalyzedGrammarType& grammar_analysis;
            std::vector<std::size_t> solving_rules;
            RuleMatchType& rule_matches;
            ComponentMatchType& component_matches;
            std::size_t& k; //TODO: figure out why I'm passing a reference
            double& geocell_propensity;
            double& tau;
            double waiting_time;
            std::unordered_map<double*, std::size_t> varmap;

            UserDataType(ModelType& model, AnalyzedGrammarType& grammar_analysis, std::vector<std::size_t>& solving_rules,
                         RuleMatchType& rule_matches, ComponentMatchType& component_matches, std::size_t& k,
                         double& geocell_propensity, double& tau, double waiting_time)
                         : model(model), grammar_analysis(grammar_analysis), solving_rules(solving_rules),
                         rule_matches(rule_matches), component_matches(component_matches),
                         k(k), geocell_propensity(geocell_propensity), tau(tau), waiting_time(waiting_time) {}
        };

        UserDataType user_data; //TODO: should this be a pointer?

        //TODO: remember, the varset/varmap is only safe so long as the map doesn't change by another thread
        Solver(ModelType& model, AnalyzedGrammarType& grammar_analysis, std::vector<std::size_t> solving_rules,
               RuleMatchType& rule_matches, ComponentMatchType& component_matches, std::size_t& k, double& geocell_propensity,
               double& tau, double waiting_time, sunindextype num_eq)
                : user_data(model, grammar_analysis, solving_rules, rule_matches, component_matches, k,
                            geocell_propensity, tau, waiting_time), num_eq(num_eq)
        {
            global_nstep = 0;
            t_start = RCONST(0.0);
            dt_out = RCONST(user_data.model->settings.DELTA_T_MIN);
            t = t_start;
            tout = t_start + dt_out;
            t_final = RCONST(user_data.model->settings.DELTA);

            flag = SUNContext_Create(NULL, &ctx);
            if(!DGGML::SundialsUtils::check_flag(&flag, "SUNContext_Create", 1))
                std::cout << "Passed the error check, suncontext created\n";

            std::cout << "*****NumEQ="<<num_eq<<"*****\n";
            y = NULL;
            y = N_VNew_Serial(num_eq, ctx);

            std::set<double*> varset;
            //set the initial conditions
            for(auto& item : user_data.solving_rules)
            {
                auto& inst = user_data.rule_matches[item];
                auto& name = inst.name;
                auto& ode = user_data.grammar_analysis.solving_rules.find(name)->second;
                //TODO: find a more efficient way
                //need to construct a graph from the match keys and
                //the mapping from the orignal LHS to the match
                //auto induced_graph = induce_from_set(inst, user_data.component_matches, user_data.model->system_graph);
                std::map<std::size_t, std::size_t> lhs_vertex_map;
                construct_grammar_match_map(inst, user_data.grammar_analysis, lhs_vertex_map, user_data.component_matches);
                std::cout << "for rule " << item << " we have a map: ";
                for(auto& [k, v] : lhs_vertex_map)
                    std::cout << "{ " << k << " -> " << v << " } ";
                std::cout << "\n";
                ode.ic(user_data.model->system_graph, lhs_vertex_map, varset);
            }
            NV_Ith_S(y, varset.size()) = user_data.tau;
            std::cout << "size of varset: " << varset.size() << "\n";
            std::size_t idx = 0;
            for(auto item : varset)
            {
                user_data.varmap.insert({item, idx});
                NV_Ith_S(y, idx) = *item;
                idx++;
            }
            varset.clear();
            //for(auto i = 0; i < num_eq; i++)
                //std::cout << NV_Ith_S(y, i) << "\n";

            arkode_mem = ERKStepCreate(rhs, t_start, y, ctx);
            //if (!DGGML::SundialsUtils::check_flag((void *)arkode_mem, "ERKStepCreate", 1))
            //    std::cout << "Passed the error check, stepper initialized\n";

            reltol = 1.0e-4;//1.0e-6;
            abstol = 1.0e-8;//1.0e-10;

            flag = ERKStepSStolerances(arkode_mem, reltol, abstol);

            //set optional inputs
            flag = ERKStepSetUserData(arkode_mem, &user_data);

            // specify the root finding function having num_roots
            flag = ERKStepRootInit(arkode_mem, num_roots, root_func);

            //ERKStepSetMinStep(arkode_mem, user_data.settings.DELTA_T_MIN/10.0);
            ERKStepSetMaxStep(arkode_mem, dt_out);//dt_out/10.0);
            std::cout << "Created solver\n";
        }

        void step()
        {
            if(num_eq == 0) return;
            flag = ERKStepEvolve(arkode_mem, tout, y, &t, ARK_NORMAL);
            std::cout << "t: " << t << ", tout: " << tout << "\n";
            if(flag == ARK_ROOT_RETURN)
            {
                root_flag = ERKStepGetRootInfo(arkode_mem, roots_found);
                std::cout << "A root has been found\n";
            }
                //successful solve
            else if(flag >= 0)
            {
                tout += dt_out;
                tout = (tout > t_final) ? t_final : tout;
            }
        }

        static int root_func(realtype t, N_Vector y, realtype* gout, void* user_data)
        {
            UserDataType* local_ptr = (UserDataType *)user_data;
            auto last = N_VGetLength(y) - 1;

            //check for when the tau equation crosses the sample
            gout[0] = NV_Ith_S(y, last) - local_ptr->waiting_time;

            return 0;
        }

        static int rhs(realtype t, N_Vector y, N_Vector ydot, void* user_data)
        {
            UserDataType* local_ptr = (UserDataType *)user_data;
            //std::cout << "running rhs\n";
            //fill ydot with zeros
            auto global_length = N_VGetLength(ydot);
            for(auto i = 0; i < global_length; i++)
                NV_Ith_S(ydot, i) = 0.0;

            for(auto& item : local_ptr->solving_rules)
            {
                auto& inst = local_ptr->rule_matches[item];
                auto& name = inst.name;
                auto& eq = local_ptr->grammar_analysis.solving_rules.find(name)->second;
                std::map<std::size_t, std::size_t> lhs_vertex_map;
                construct_grammar_match_map(inst, local_ptr->grammar_analysis, lhs_vertex_map, local_ptr->component_matches);
                eq.ode(local_ptr->model->system_graph, lhs_vertex_map, y, ydot, local_ptr->varmap);
            }
            NV_Ith_S(ydot, global_length-1) = local_ptr->geocell_propensity;

            local_ptr = nullptr;

            return 0;
        }

        void copy_back()
        {
            for(auto& [item, key] : user_data.varmap)
            {
                *item = NV_Ith_S(y, key);
            }
            auto global_length = N_VGetLength(y);
            user_data.tau = NV_Ith_S(y, global_length-1);
        }

        //TODO: make this function reset the whole y vector
        //since it may change in size
        void reinit(std::vector<std::size_t> solving_rules)
        {
            long int nst;
            ERKStepGetNumSteps(arkode_mem, &nst);
            global_nstep += nst;
            user_data.solving_rules = solving_rules;
            //std::cout << "Reintializing...\n";
            auto pre_eq = num_eq;
            num_eq = 0;
            for(auto& item : user_data.solving_rules)
            {
                auto& name = user_data.rule_matches[item].name;
                num_eq += user_data.grammar_analysis.solving_rules.find(name)->second.num_eq;
            }
            num_eq++; //one extra equation for tau
            std::cout << "Previo # of eq: " << pre_eq << "\n";
            std::cout << "Reinit # of eq: " << num_eq << "\n";
            N_VDestroy(y);
            y = N_VNew_Serial(num_eq, ctx);

            //clear the old varmap
            user_data.varmap.clear();

            //rebuild the ic
            std::set<double*> varset;
            //set the initial conditions
            for(auto& item : user_data.solving_rules)
            {
                auto& inst = user_data.rule_matches[item];
                auto& name = inst.name;
                auto& ode = user_data.grammar_analysis.solving_rules.find(name)->second;
                //TODO: find a more efficient way
                std::map<std::size_t, std::size_t> lhs_vertex_map;
                construct_grammar_match_map(inst, user_data.grammar_analysis, lhs_vertex_map, user_data.component_matches);
                ode.ic(user_data.model->system_graph, lhs_vertex_map, varset);
            }
            NV_Ith_S(y, varset.size()) = user_data.tau;
            std::size_t idx = 0;
            std::cout << "Global length: " << N_VGetLength(y) << "\n";
            std::cout << "Local length: " << N_VGetLocalLength(y) << "\n";
            std::cout << "Varset length: " << varset.size() << "\n";
            for(auto item : varset)
            {
                user_data.varmap.insert({item, idx});
                NV_Ith_S(y, idx) = *item;
                idx++;
            }
            varset.clear();

            user_data.tau = 0.0;
            NV_Ith_S(y, num_eq-1) = 0.0;

            if(num_eq == pre_eq)
                ERKStepReInit(arkode_mem, rhs, t, y);
            else
            {
                ERKStepResize(arkode_mem, y, 1.0, t, NULL, NULL);
                ERKStepReInit(arkode_mem, rhs, t, y);
            }
        }

        void print_stats()
        {
            long int nst, nst_a, nfe, netf;
            /* Print some final statistics */
            flag = ERKStepGetNumSteps(arkode_mem, &nst);
            global_nstep += nst;
            flag = ERKStepGetNumStepAttempts(arkode_mem, &nst_a);
            flag = ERKStepGetNumRhsEvals(arkode_mem, &nfe);
            flag = ERKStepGetNumErrTestFails(arkode_mem, &netf);

            printf("\nFinal Solver Statistics:\n");
            printf("   Internal solver steps = %li (attempted = %li)\n", nst, nst_a);
            printf("   Total RHS evals = %li\n", nfe);
            printf("   Total number of error test failures = %li\n\n", netf);
            std::cout << "Global number of steps: " << global_nstep << "\n";
        }
        ~Solver()
        {
            //std::cout << "Starting solver destruction\n";
            std::cout << "Global length: " << N_VGetLength(y) << "\n";
            std::cout << "Local length: " << N_VGetLocalLength(y) << "\n";
            std::cout << "Varset length: " << user_data.varmap.size() << "\n";
            N_VDestroy(y);
            //std::cout << "Destroyed y vector\n";
            ERKStepFree(&arkode_mem); //free the solver memory
            //std::cout << "Destroyed arkode_mem\n";
            SUNContext_Free(&ctx); //always call prior to MPI_Finalize
            //std::cout << "Destroyed the solver\n";

            /* Step 13: Finalilze MPI, if used */
        }
    };
} // DGGML

#endif //DGGML_SOLVER_H
